

options {
  STATIC = true;
}



PARSER_BEGIN(Rando)

package compiler;
import java.io.PrintStream;
import java.util.*;
import symbol_table.*;
import syntax_tree.*;
import interpreter.*;



public class Rando
{
  
  //Deklarimi i tabeles se simboleve
  public static LookupTable symbolTable=new LookupSymbolTable();

  
  //Deklari i objekti te cilet do jape mundesi perdoruesit te fuse te dhena
  public static  Scanner jin=new Scanner(System.in);

  //Deklarimi i interpretuesit
  public static Interpreter interpreter=new Interpreter();

  //Metoda qe do te kontrolloje per 
  public static boolean isNumeric(String str)
  {
  return str.matches("-?\\d+(\\.\\d+)?");  //match a number with optional '-' and decimal.
  }


  //Metoda Kryesore qe therret te gjithe aplikacionin
  public static void main(String args[]) throws ParseException
  {
     Rando parser = new Rando(System.in);
	     int x=0;
     while (x==0)
    {
      System.out.println("Reading from standard input...");
      try
      {
        switch (Rando.one_line())
        {
          case 0 : 
          System.out.println("OK.");
          break;
          case 1 : 
          System.out.println("Terminate.");
          x=1;
          break;
          default : 
          break;
        }
      }
      catch (Exception e)
      {
        System.out.println("Error.");
        Rando.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
        break;
      }
    }
     //parser.Start();
  }
  


}



PARSER_END(Rando)



SKIP :
{
    " "
  | "\t"
  | "\n"
  | "\r"
  | "\r\n"
  | <"\"" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>

}

TOKEN :
/*
KEYWORDS
*/
{
      < INCLUDE: "perfshi" >
|     < IF: "Nqs" >
|     < WHILE: "Gjersa" >
|     < DO: "do" >
|     < STOP: "stop" >
|     < DEF : "def" >
|     < BEGIN : "Fillim" >
|     < END : "Fund" >
|     < OR : "ose" >
|     < AND : "dhe" >
|     < NOT : "!" >
|     < TRUE : "true" >
|     < FALSE : "false" >

}

TOKEN :
/* SYMBOLS */
{
      < DOT: "." >
|     < COLON: ":" >
|     < EQ: "==" >
|     < GT: ">"  >
|     < LT: "<"  >
|     < GE: ">=" >
|     < LE: "<=" >
|     < NE: "!=" >
|     < PLUS: "+">
|     < MINUS: "-" >
|     < MUL: "*" >
|     < DIV: "/" >
|     < MOD: "%" >
|     < ASSIGN: "=" >
|     < OPEN_PAR: "(" >
|     < CLOSE_PAR: ")" >
|     < OPEN_BRACKET:"<[" >
|     < CLOSE_BRACKET:"]" >
}

TOKEN :
/* LITERALS */
{
  < INTEGER_LITERAL:  ["1"-"9"] ( ["0"-"9"])* | "0"   >

 
  
  | <STRING_LITERAL: ( ("'") (["a"-"z"] | ["A"-"Z"] |  "_"  | "-" | "?"  | "#" | "@"| "$" | "!" | "*" | "="| "/" | "*" | " " | ["0"-"9"])*("'"))*> 
}

TOKEN :
/* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|  < #LETTER: ["_","a"-"z","A"-"Z"] >
|  < #DIGIT: ["0"-"9"] >
}

SPECIAL_TOKEN :
{
  	<SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
  | <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}


/** Looping*/
int one_line() :
{}
{
   Start() ";"
  {
    return 0;
  }
| ";"
  {
    return 1;
  }
}

void Start():
{
  Exp r;
  int val;
  Token t;
  boolean b;
}
{
	(	   Include()
	 )*
	 < BEGIN>

		b=logicExp()
				{
		  System.out.println(b);		}	
	 < END>
}


void Include():
{}
{
 	   < INCLUDE >
      (
        < IDENTIFIER >
      )+
 
}


/*
------------------------------
Logic Exp
------------------------------
*/

public boolean logicExp():
{
  boolean flag1;
  boolean flag2;}
{
  flag1=andExp()
  (
    < OR>
    flag2=logicExp()
    {
      flag1=flag1 || flag2;    }  )*
  {
    return flag1;  }}


public boolean andExp():
{
  boolean flag1;
  boolean flag2;}
{	flag1=notExp()
	(
	  < AND >
	  flag2=andExp()	  {
	    flag1=flag1 && flag2;	  }	)*
	{
	  return flag1;	}
}


public boolean notExp():
{
  boolean flag;}
{
  (    
	  < NOT> flag=equalExp()	  {
	    flag=!flag;	  }
	  
	| flag=equalExp()


  )
  
	{
	  return flag;	}
}


public boolean equalExp():
{
  boolean flag1;
  boolean flag2;}
{
  flag1=literal()
  (
    < EQ> flag2=equalExp()
    {
      flag1=flag1==flag2;    }
  |
  	< NE > flag2=equalExp()
  	{
  	  flag1=flag1!=flag2;  	}  )*
  
  {
    return flag1;  }
  }



public boolean literal():
{	boolean flag;
	Token t;
	
}
{
	  (	    
		  t=< TRUE>			  {
			    flag= true;			  }
		  
		| t=< FALSE>
			  {
				flag=false;			  }
		  
	
		|  flag=Relation()

		//| < OPEN_PAR > flag=logicExp() < CLOSE_PAR >				
	 )
	 
	 {
	   return flag;	 }

	
}




public boolean Relation():
{
    Exp e1,e2;
	int num1;
	int num2;
	boolean flag=false;}
{
	
	  	    
		  e1=mathExp()		  {
		    num1=e1.eval();		  }
		  (
			    < GT>  e2=mathExp()
			    {
			      num2=e2.eval();
			      flag=num1 > num2;			    }
			
			  | < GE>  e2=mathExp()
			  {
			      num2=e2.eval();	    
			      flag=num1 >= num2;
			  }
		
			  |  <LT>  e2=mathExp()
			  {
			      num2=e2.eval();	   				  flag=num1 < num2;
			  }
		
			  |  <LE>  e2=mathExp()
			  {
			     num2=e2.eval();	    
			     flag=num1<=num2;			  }
			  | 
			    <EQ>e2=mathExp()
			    {
			      num2=e2.eval();
			      flag=num1==num2;
			    }
			  |
			  	<NE> e2=mathExp()
			  	{
			  	  num2=e2.eval();
			  	  flag=num1!=num2;
			  	}		  )	

	 {   
	  return flag;
	 }
 }



/*
------------------------------
Math Exp
------------------------------
*/


Exp mathExp():
{
    Exp num1;
    Exp num2;
    int num;
}
{
    num1=term()
    (
        < PLUS>  num2=mathExp()    { num1= new PlusExp(num1,num2);}
    |   < MINUS> num2=mathExp()    { num1=new MinusExp(num1,num2); }
    )*
    
   { return num1; }
}




Exp term():
{
	Exp num1;
	Exp num2;
}
{
    num1=unary()
    (
        < MUL>    num2=term()    { num1=new MulExp(num1,num2); }
    |   < DIV>    num2=term()    { num1=new DivExp(num1,num2); }
    |   < MOD>    num2=term()    { num1=new ModExp(num1,num2); }
    )*
   { return num1; }
}



Exp unary():
{
    Exp num1;
}
{
    < MINUS> num1=primary()         { return new NegativeExp(num1);  }
|            num1=primary()         { return  new PositiveExp(num1); }
}




Exp primary():
{
    Token t;
    Exp num1;
}
{
    t=<INTEGER_LITERAL>                                   { return new IntegerLiteral(t.image); }
|   t=< IDENTIFIER >														  {
														         return new Identifier(t.image,symbolTable);														  }
|   t=< STRING_LITERAL>									  {      return new StringLiteral(t.image);}  
|   < OPEN_PAR >  num1=mathExp() < CLOSE_PAR >            { return num1; }
}


