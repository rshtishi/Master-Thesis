

options {
  STATIC = true;
}



PARSER_BEGIN(Rando)

package compiler;
import java.io.PrintStream;
import java.util.*;
import abstract_syntax_tree.*;
import symbol_table.*;



public class Rando
{
  //Deklarimi i tabeles se simboleve
  public static LookupTable symbolTable=new LookupSymbolTable();
  //Deklari i objekti te cilet do jape mundesi perdoruesit te fuse te dhena
  public static  Scanner jin=new Scanner(System.in);

  //Metoda qe do te kontrolloje per 
  public static boolean isNumeric(String str)
  {
  return str.matches("-?\\d+(\\.\\d+)?");  //match a number with optional '-' and decimal.
  }

  //Metoda Kryesore qe therret te gjithe aplikacionin
  public static void main(String args[]) throws ParseException
  {
     Rando parser = new Rando(System.in);
     int x=0;
     while (x==0)
    {
      System.out.println("Reading from standard input...");
      try
      {
        switch (Rando.one_line())
        {
          case 0 : 
          System.out.println("OK.");
          break;
          case 1 : 
          System.out.println("Terminate.");
          x=1;
          break;
          default : 
          break;
        }
      }
      catch (Exception e)
      {
        System.out.println("Error.");
        Rando.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
        break;
      }
    }
     //parser.Start();
  }
  
  double previousValue=0.0;

}



PARSER_END(Rando)



SKIP :
{ " " | "\t" | "\n" | "\r" | "\r\n" }

TOKEN:{< EVAL:"#">}
TOKEN:{< REVAL:"?">}
TOKEN:{< PLUS:"+">}
TOKEN:{< MINUS:"-">}
TOKEN:{< TIMES:"*">}
TOKEN:{< DIVIDE:"/">}
TOKEN:{< MOD:"%">}
TOKEN:{< EQUAL:"=">}
TOKEN:{< ET:"==">}
TOKEN:{< NET:"!=">}
TOKEN:{< GT:">">}
TOKEN:{< LT:"<">}
TOKEN:{< GET:">=">}
TOKEN:{< LET:"<=">}
TOKEN:{< COMMA:",">}
TOKEN:{<NUMBER: < DIGITS >| < DIGITS >"."< DIGITS >  | < DIGITS >"." | "."< DIGITS >>}
TOKEN:{< #DIGITS:(["0"-"9"])+>}
TOKEN:{< OPEN_PAR:"(">}
TOKEN:{< CLOSE_PAR:")">}
TOKEN:{< PREVIOUS:"$">}
TOKEN:{ < FILLIM: "Fillim">}
TOKEN:{ < FUND: "Fund">}
TOKEN:{ < LEXO: "Lexo">}
TOKEN:{ < SHKRUAJ: "Shkruaj">}
TOKEN:{ < RSHKRUAJ: "RShkruaj">}
TOKEN:{< NDRYSHORE:( ((["a"-"z"])+ | (["A"-"Z"])+ ) ("_" | "-" | ["a"-"z"] | ["A"-"Z"] | ["0"-"9"])*)>}
TOKEN:{< FJALI:( ("'") (["a"-"z"] | ["A"-"Z"] |  "_"  | "-" | "?"  | "#" | "@"| "$" | "!" | "*" | "="| "/" | "*" | " " | ["0"-"9"])*("'"))*>}


/** Looping*/
int one_line() :
{}
{
   Start() ";"
  {
    return 0;
  }
| ";"
  {
    return 1;
  }
}

void Start() throws NumberFormatException:
{Token t;}
{
  < FILLIM>
    Action()
  < FUND >
  
}


Exp expression() :
{
	Exp num1,num2;
}
{
   num1= term()
  (
    (
      < PLUS > num2=term()		      {
		        num1=new PlusExp(num1,num2);		      }
      |
      < MINUS > num2=term()
		      {
		        num1=new MinusExp(num1,num2);		      }
    )
    
  )*
  {
    return num1;  }}


Exp term() :
{
  Exp num1;
  Exp num2;
}
{
  num1=unary()
  (
    (
       < TIMES > num2= unary()
	       {
	         num1=new TimesExp(num1,num2);	       }
     |
       < DIVIDE > num2=unary()
	       {
	         num1=new DivideExp(num1,num2);		   }
     |
    <MOD > num2=unary()
	       {
	         num1=new ModuleExp(num1,num2);
		   }
    )
   
  )*
  {
    return num1;  }
}

Exp unary() :
{
  Exp num1;
}
{
    < MINUS > num1=element()	    {
	      num1= new NegativeExp(num1);
	      return num1;	    }
   |
     num1=element()
	     {
	       num1=new PositiveExp(num1);
	       return num1;	     }
}

Exp element() :
{Token t; Exp num1;}
{
    t=<NDRYSHORE >
     {
    	return new Identifier(t.image,symbolTable);
     }
   | 
 	 t=< NUMBER >
 	 	{
 	 	  return new IntegerLiteral(t.image);
 	 	}
	|
  	 < OPEN_PAR > num1= expression()	  	 {
	  	   return num1;	  	 }
  	 < CLOSE_PAR >
}


public void Action():
{Token t=null,v=null; Exp r; boolean b=false;}
{
		(
	  	< LEXO > t=< NDRYSHORE> 
		{
		  
		  String id=t.image;
		  String value=jin.next();
		  String type;
		  if(isNumeric(value))
		  {
		    type="Number";
		  }
		  else
		  {
		    type="String";
		  }
		  value=value.replace("'","");
		  symbolTable.put(id,new Symbol(value,type));   
		}
		(
		  < COMMA> t=< NDRYSHORE>
		  {
		     
			  id=t.image;
			  value=jin.next();
			  if(isNumeric(value))
			  {
			    type="Number";
			  }
			  else
			  {
			    type="String";
			  }
			  value=value.replace("'","");
			  symbolTable.put(id,new Symbol(value,type));   
		  } 
		)*
		
		|
		
		   < SHKRUAJ>  (   r=expression()  )  
	
			   {
				 System.out.print(r.eval()); 
			   }
	
			(
			  < COMMA>  (  r=expression()  ) 
			   {
				     System.out.print(r.eval()); 	
			   }
			)*
		
        | 
		< RSHKRUAJ>  (  r=expression()  ) 

		   {
		      System.out.println();
		      
		      System.out.println(r.eval()); 	
			  
		   }

				(
				  < COMMA>  ( r=expression()  )
				   {
					    System.out.println(r.eval()); 	
				   }
				)*
		
		|
		
		t= < NDRYSHORE> < EQUAL>   ( r=expression() )
		{
		    id=t.image;			value=""+r.eval();
					
			symbolTable.put(id,new Symbol(value,"Number"));
		}
       
	 
	)*
}






