

options {
  STATIC = true;
}



PARSER_BEGIN(Rando)

package compiler;
import java.io.PrintStream;
import java.util.*;
import symbol_table.*;
import syntax_tree.math.*;
import syntax_tree.logic.*;
import syntax_tree.statement.*;
import interpreter.*;



public class Rando
{
  
  //Deklarimi i tabeles se simboleve
  public static LookupTable symbolTable=new LookupSymbolTable();

  
  //Deklari i objekti te cilet do jape mundesi perdoruesit te fuse te dhena
  public static  Scanner jin=new Scanner(System.in);

  //Deklarimi i interpretuesit
  public static Interpreter interpreter=new Interpreter();


  	//Metoda qe do te kontrolloje per 
	public static boolean isNumeric(String str)
	{
	  return str.matches("-?\\d+(\\.\\d+)?");  //match a number with optional '-' and decimal.
	}


  //Metoda Kryesore qe therret te gjithe aplikacionin
  public static void main(String args[]) throws ParseException
  {
     Rando parser = new Rando(System.in);
	     int x=0;
     while (x==0)
    {
      System.out.println("Reading from standard input...");
      try
      {
        switch (Rando.one_line())
        {
          case 0 : 
          System.out.println("OK.");
          break;
          case 1 : 
          System.out.println("Terminate.");
          x=1;
          break;
          default : 
          break;
        }
      }
      catch (Exception e)
      {
        System.out.println("Error.");
        Rando.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
        break;
      }
    }
     //parser.Start();
  }
  


}



PARSER_END(Rando)



SKIP :
{
    " "
  | "\t"
  | "\n"
  | "\r"
  | "\r\n"
  | <"\"" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>

}

TOKEN :
/*
KEYWORDS
*/
{
      < INCLUDE: "perfshi" >
|     < IF: "Nqs" >
|     < WHILE: "Gjersa" >
|     < DO: "do" >
|     < STOP: "stop" >
|     < DEF : "def" >
|     < PRINT : "Shkruaj" >
|     < PRINTLN : "RShkruaj" >
|     < READ : "Lexo" >
|     < BEGIN : "Fillim" >
|     < END : "Fund" >
|     < OR : "ose" >
|     < AND : "dhe" >
|     < NOT : "!" >
|     < TRUE : "true" >
|     < FALSE : "false" >

}

TOKEN :
/* SYMBOLS */
{
      < DOT: "." >
|     < COMMA: "," >
|     < COLON: ":" >
|     < EQ: "==" >
|     < GT: ">"  >
|     < LT: "<"  >
|     < GE: ">=" >
|     < LE: "<=" >
|     < NE: "!=" >
|     < PLUS: "+">
|     < MINUS: "-" >
|     < MUL: "*" >
|     < DIV: "/" >
|     < MOD: "%" >
|     < ASSIGN: "=" >
|     < OPEN_PAR: "(" >
|     < CLOSE_PAR: ")" >
|     < OPEN_BRACKET:"[" >
|     < CLOSE_BRACKET:"]" >
}

TOKEN :
/* LITERALS */
{
  < INTEGER_LITERAL:  ("-")?["1"-"9"] ( ["0"-"9"])* | "0"   >

 
  
  | <STRING_LITERAL: ( ("'") (["a"-"z"] | ["A"-"Z"] |  "_"  | "-" | "?"  | "#" | "@"| "$" | "!" | "*" | "="| "/" | "*" | " " | ["0"-"9"])*("'"))*> 
}

TOKEN :
/* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|  < #LETTER: ["_","a"-"z","A"-"Z"] >
|  < #DIGIT: ["0"-"9"] >
}

SPECIAL_TOKEN :
{
  	<SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
  | <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}


/** Looping*/
int one_line() :
{}
{
   Start() ";"
  {
    return 0;
  }
| ";"
  {
    return 1;
  }
}

void Start():
{
  MathExp r;
  int val;
  Token t;
  boolean b;
  LogicExp l;
  MathExp e;
  Statement s;
}
{
	(	   Include()
	 )*
< BEGIN >
(
assign()
|
read()
|
print()
|
println()
)*
< END>
}


void Include():
{}
{
 	   < INCLUDE >
      (
        < IDENTIFIER >
      )+
 
}

/*
------------------------------
Statements
------------------------------
*/

void assign():
{	Token t;
	MathExp e;
	LogicExp l;
}
{	< IDENTIFIER > <ASSIGN >
	(
	  	  t=< IDENTIFIER >
	  	  
	 	| t=< STRING_LITERAL>

		|  e=mathExp()

		| < OPEN_BRACKET > l=logicExp()  < CLOSE_BRACKET >
	 	 	)
}

void read():
{
  Token t;
  Statement stmt=null;}
{
  < READ>
  (
     t=< IDENTIFIER>
	{
		  stmt=new Read(t.image,jin,symbolTable);
		  stmt.eval();	}
     (
       < COMMA >
        t=< IDENTIFIER>
         {
		  stmt=new Read(t.image,jin,symbolTable);
		  stmt.eval();
		 }     )*  ) }

void print():
{
  LogicExp l;
  MathExp e;
  Token t;
  Statement stmt=null;}
{
            
  		< PRINT>
  				(
	  				  	 t=< STRING_LITERAL> { stmt=new Print(t.image);  }
	  				  	 
				 	 |      e=mathExp()  { stmt=new Print(e); }
	
				 	 | <OPEN_BRACKET> l=logicExp() { stmt=new Print(l);} <CLOSE_BRACKET>
						
				)

				{					stmt.eval();
				}

				(
					  < COMMA>
	
					    		(
					  				  	 t=< STRING_LITERAL> { stmt=new Print(t.image);  }
					  				  	 
									 	 |      e=mathExp()  { stmt=new Print(e); }
						
									 	 | <OPEN_BRACKET> l=logicExp() { stmt=new Print(l);} <CLOSE_BRACKET>
										
								)
	
					{
						stmt.eval();
					}
				 
				  				)*
		
	}

void println():
{
  LogicExp l;
  MathExp e;
  Token t;
  Statement stmt=null;
}
{
     
       
  		< PRINTLN>
  				(
	  				  	 t=< STRING_LITERAL> { stmt=new Println(t.image);  }
	  				  	 
				 	 |      e=mathExp()  { stmt=new Println(e); }
	
				 	 | <OPEN_BRACKET> l=logicExp() { stmt=new Println(l);} <CLOSE_BRACKET>
						
				)

				{
					stmt.eval();
				}

				(
				  < COMMA>

				    		(
				  				  	 t=< STRING_LITERAL> { stmt=new Println(t.image);  }
				  				  	 
								 	 |      e=mathExp()  { stmt=new Println(e); }
					
								 	 | <OPEN_BRACKET> l=logicExp() { stmt=new Println(l);} <CLOSE_BRACKET>
									
							)

				{
					stmt.eval();
				}
				 
				  
				)*
		
	
}

/*
------------------------------
Logic LogicExp
------------------------------
*/


public LogicExp logicExp():
{
	LogicExp l1;
	LogicExp l2;
}
{
  l1=andExp()
  (
    < OR>
    l2=logicExp()
    {
      l1=new OrExp(l1,l2);
    }
  )*
  {
    return l1;
  }
}


public LogicExp andExp():
{
	LogicExp l1;
	LogicExp l2;
}
{
	l1=notExp()
	(
	  < AND >
	  l2=andExp()
	  {
	    l1=new AndExp(l1,l2);
	  }
	)*
	{
	  return l1;
	}
}

public LogicExp notExp():
{
	LogicExp l1;
}
{
  (
    
	  < NOT> l1=equalExp()
		{
		   return l1;
		}
	  
	| l1=equalExp()
		{
		   return l1;
		}


  )

}


public LogicExp equalExp():
{
	LogicExp l1;
	LogicExp l2;
}
{
  l1=literal()
  (
    < EQ> l2=equalExp()
    {
      l1=new EqualExp(l1,l2);
    }
  |
  	< NE > l2=equalExp()
  	{
  	  l1=new InEqualExp(l1,l2);
  	}
  )*
  
  {
    return l1;
  }
  
}



public LogicExp literal():
{
	LogicExp l1;
	Token t;
	
}
{
	  (
	    
		  < TRUE>
			  {
			    return new TrueLiteral();
			  }
		  
		| < FALSE>
			  {
				return new FalseLiteral();
			  }



		| l1= relation()
			  {
				return l1;
			  }

		| < OPEN_PAR > l1=logicExp() < CLOSE_PAR >
			  {
			    return l1;
			  }
			
	
	 )
	 

}





public LogicExp relation():
{
	LogicExp e1;
	Token t1,t2;
	String type1;
	String type2;
	
}
{    
		 (		    t1=< INTEGER_LITERAL>{ type1="Number"; }
		  |
		  	t1=< IDENTIFIER> { type1="Identifier"; }
		  |
		  	t1=< STRING_LITERAL> { type1="String"; }
   
		)
		
		  (		    	  
				    < GT>
				    		(
					      		 t2=< INTEGER_LITERAL>
							    {
							      	 type2="Number";
							         e1=new RelGTExp(t1.image,type1,t2.image,type2,symbolTable);
							    }
							  |
							  	t2=< IDENTIFIER>
							    {
							      	 type2="Identifier";
							         e1=new RelGTExp(t1.image,type1,t2.image,type2,symbolTable);
							    }
							  |
							  	t2=< STRING_LITERAL>
							    {
							      	 type2="String";
							         e1=new RelGTExp(t1.image,type1,t2.image,type2,symbolTable);
							    }

						    )
			
			
			  | < GE>
				    		(
					      		 t2=< INTEGER_LITERAL>
							    {
							      	 type2="Number";
							         e1=new RelGEExp(t1.image,type1,t2.image,type2,symbolTable);
							    }
							  |
							  	t2=< IDENTIFIER>
							    {
							      	 type2="Identifier";
							         e1=new RelGEExp(t1.image,type1,t2.image,type2,symbolTable);
							    }
							  |
							  	t2=< STRING_LITERAL>
							    {
							      	 type2="String";
							         e1=new RelGEExp(t1.image,type1,t2.image,type2,symbolTable);
							    }
						    )
		
			  |  <LT>
				    		(
					      		 t2=< INTEGER_LITERAL>
							    {
							      	 type2="Number";
							         e1=new RelLTExp(t1.image,type1,t2.image,type2,symbolTable);
							    }
							  |
							  	t2=< IDENTIFIER>
							    {
							      	 type2="Identifier";
							         e1=new RelLTExp(t1.image,type1,t2.image,type2,symbolTable);
							    }
							  |
							  	t2=< STRING_LITERAL>
							    {
							      	 type2="String";
							         e1=new RelLTExp(t1.image,type1,t2.image,type2,symbolTable);
							    }
						    )
			  
		
			  |  <LE>
				    		(
					      		 t2=< INTEGER_LITERAL>
							    {
							      	 type2="Number";
							         e1=new RelLEExp(t1.image,type1,t2.image,type2,symbolTable);
							    }
							 |
							  	t2=< IDENTIFIER>
							    {
							      	 type2="Identifier";
							         e1=new RelLEExp(t1.image,type1,t2.image,type2,symbolTable);
							    }
							  |
							  	t2=< STRING_LITERAL>
							    {
							      	 type2="String";
							         e1=new RelLEExp(t1.image,type1,t2.image,type2,symbolTable);
							    }
						    )			
			  
			  | 
			    <EQ>
			    			(
					      		 t2=< INTEGER_LITERAL>
							    {
							      	 type2="Number";
							         e1=new RelEQExp(t1.image,type1,t2.image,type2,symbolTable);
							    }
							  | 
							    t2=< IDENTIFIER>
							    {
							      	 type2="Identifier";
							         e1=new RelEQExp(t1.image,type1,t2.image,type2,symbolTable);
							    }
							  |
							  	t2=< STRING_LITERAL>
							    {
							      	 type2="String";
							         e1=new RelEQExp(t1.image,type1,t2.image,type2,symbolTable);
							    }
						    )
			  |
			  	<NE>
			  				 (
					      		 t2=< INTEGER_LITERAL>
							    {
							      	 type2="Number";
							         e1=new RelNEExp(t1.image,type1,t2.image,type2,symbolTable);
							    }
							  | 
							    t2=< IDENTIFIER>
							    {
							      	 type2="Identifier";
							         e1=new RelNEExp(t1.image,type1,t2.image,type2,symbolTable);
							    }
							  |
							  	t2=< STRING_LITERAL>
							    {
							      	 type2="String";
							         e1=new RelNEExp(t1.image,type1,t2.image,type2,symbolTable);
							    }
						    )
		  )	

	 {   
	  return e1;
	 }
 
}





/*
------------------------------
Math MathExp
------------------------------
*/


MathExp mathExp():
{
    MathExp num1;
    MathExp num2;
    int num;
}
{
    num1=term()
    (
        < PLUS>  num2=mathExp()    { num1= new PlusExp(num1,num2);}
    |   < MINUS> num2=mathExp()    { num1=new MinusExp(num1,num2); }
    )*
    
   { return num1; }
}




MathExp term():
{
	MathExp num1;
	MathExp num2;
}
{
    num1=unary()
    (
        < MUL>    num2=term()    { num1=new MulExp(num1,num2); }
    |   < DIV>    num2=term()    { num1=new DivExp(num1,num2); }
    |   < MOD>    num2=term()    { num1=new ModExp(num1,num2); }
    )*
   { return num1; }
}



MathExp unary():
{
    MathExp num1;
}
{
    < MINUS> num1=primary()         { return new NegativeExp(num1);  }
|            num1=primary()         { return  new PositiveExp(num1); }
}




MathExp primary():
{
    Token t;
    MathExp num1;
}
{
    t=<INTEGER_LITERAL>                                   { return new IntegerLiteral(t.image); }
    
    
|   t=< IDENTIFIER >														  {
														         return new IdentifierMath(t.image,symbolTable);														  }
														  
														   
|   < OPEN_PAR >  num1=mathExp() < CLOSE_PAR >            { return num1; }


}


