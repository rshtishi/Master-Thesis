

options {
  STATIC = true;
}



PARSER_BEGIN(Rando)

package projekti;
import java.io.PrintStream;
import java.util.*;



public class Rando
{
  //Deklarimi i tabeles se simboleve
  public static LookupTable symbolTable=new LookupSymbolTable();
  //Deklari i objekti te cilet do jape mundesi perdoruesit te fuse te dhena
  public static  Scanner jin=new Scanner(System.in);

  //Metoda qe do te kontrolloje per 
  public static boolean isNumeric(String str)
  {
  return str.matches("-?\\d+(\\.\\d+)?");  //match a number with optional '-' and decimal.
  }

  //Metoda Kryesore qe therret te gjithe aplikacionin
  public static void main(String args[]) throws ParseException
  {
     Rando parser = new Rando(System.in);
     int x=0;
     while (x==0)
    {
      System.out.println("Reading from standard input...");
      try
      {
        switch (Rando.one_line())
        {
          case 0 : 
          System.out.println("OK.");
          break;
          case 1 : 
          System.out.println("Terminate.");
          x=1;
          break;
          default : 
          break;
        }
      }
      catch (Exception e)
      {
        System.out.println("Error.");
        Rando.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
        break;
      }
    }
     //parser.Start();
  }
  
  double previousValue=0.0;

}



PARSER_END(Rando)



SKIP :
{ " " | "\t" | "\n" | "\r" | "\r\n" }

TOKEN:{< EVAL:"#">}
TOKEN:{< REVAL:"?">}
TOKEN:{< PLUS:"+">}
TOKEN:{< MINUS:"-">}
TOKEN:{< TIMES:"*">}
TOKEN:{< DIVIDE:"/">}
TOKEN:{< MOD:"%">}
TOKEN:{< EQUAL:"=">}
TOKEN:{< ET:"==">}
TOKEN:{< NET:"!=">}
TOKEN:{< GT:">">}
TOKEN:{< LT:"<">}
TOKEN:{< GET:">=">}
TOKEN:{< LET:"<=">}
TOKEN:{< COMMA:",">}
TOKEN:{<NUMBER: < DIGITS >| < DIGITS >"."< DIGITS >  | < DIGITS >"." | "."< DIGITS >>}
TOKEN:{< #DIGITS:(["0"-"9"])+>}
TOKEN:{< OPEN_PAR:"(">}
TOKEN:{< CLOSE_PAR:")">}
TOKEN:{< PREVIOUS:"$">}
TOKEN:{ < FILLIM: "Fillim">}
TOKEN:{ < FUND: "Fund">}
TOKEN:{ < LEXO: "Lexo">}
TOKEN:{ < SHKRUAJ: "Shkruaj">}
TOKEN:{ < RSHKRUAJ: "RShkruaj">}
TOKEN:{< NDRYSHORE:( ((["a"-"z"])+ | (["A"-"Z"])+ ) ("_" | "-" | ["a"-"z"] | ["A"-"Z"] | ["0"-"9"])*)>}
TOKEN:{< FJALI:( ("'") (["a"-"z"] | ["A"-"Z"] |  "_"  | "-" | "?"  | "#" | "@"| "$" | "!" | "*" | "="| "/" | "*" | " " | ["0"-"9"])*("'"))*>}


/** Looping*/
int one_line() :
{}
{
   Start() ";"
  {
    return 0;
  }
| ";"
  {
    return 1;
  }
}

void Start() throws NumberFormatException:
{Token t;}
{
  < FILLIM>
    Action()
  < FUND >
  
}


boolean rExp():
{
  
  int num1;
  int num2;
}
{
	num1=rTerm()
	(
	  (
	    < ET> num2=rTerm() {  return (num1==num2);}
	  |
	    < NET> num2=rTerm() {  return (num1!=num2);}
	  |
	    < GT> num2=rTerm() {  return (num1 > num2);}
	  |
	    < LT> num2=rTerm() {  return (num1 < num2);}
	  |
	    < GET> num2=rTerm() {  return (num1 >= num2);}
	  |
	    < LET> num2=rTerm() {  return (num1 <= num2);}
	  )
	)*
}

int rTerm():
{
  Token t;
  int r;
}
{
   	    t=< NUMBER >
 	 	{
 	 	  return Integer.parseInt(t.image);
 	 	}
 	| 
 	 	t=<NDRYSHORE >
 	 	{
 	 	        if(symbolTable.containsKey(t.image))
				{
				      String val=symbolTable.getValue(t.image);
				      return Integer.parseInt(val);
				}
				else
				{
				      return 0;
				}
 	 	}
	|
	   t=< EVAL> r=expression()
	   {
	      return r;
	   }
}
int expression() :
{
  int num1;
  int num2;
}
{
   num1= term()
  (
    (
      < PLUS > num2=term()
		      {
		        num1+=num2;
		      }
      |
      < MINUS > num2=term()
		      {
		        num1-=num2;
		      }
    )
    
  )*
  {
    return num1;
  }
}


int term() :
{
  int num1;
  int num2;
}
{
  num1=unary()
  (
    (
       < TIMES > num2= unary()
	       {
	         num1*=num2;
	       }
     |
       < DIVIDE > num2=unary()
	       {
	         num1/=num2;
		   }
     |
    <MOD > num2=unary()
	       {
	         num1%=num2;
		   }
    )
   
  )*
  {
    return num1;
  }
}

int unary() :
{
  int num1;
}
{
    < MINUS > num1=element()
	    {
	      return -num1;
	    }
   |
     num1=element()
	     {
	       return num1;
	     }
}

int element() :
{Token t; int num1;}
{
    t=<NDRYSHORE >
     {
       	if(symbolTable.containsKey(t.image))
		{
		      String val=symbolTable.getValue(t.image);
		      return Integer.parseInt(val);
		}
		else
		{
		      return 0;
		}
     }
   | 
 	 t=< NUMBER >
 	 	{
 	 	  return Integer.parseInt(t.image);
 	 	}
	|
  	 < OPEN_PAR > num1= expression()
	  	 {
	  	   return num1;
	  	 }
  	 < CLOSE_PAR >
}


public void Action():
{Token t=null,v=null; int r=0; boolean b=false;}
{
		(
	  	< LEXO > t=< NDRYSHORE> 
		{
		  
		  String id=t.image;
		  String value=jin.next();
		  String type;
		  if(isNumeric(value))
		  {
		    type="Number";
		  }
		  else
		  {
		    type="String";
		  }
		  value=value.replace("'","");
		  symbolTable.put(id,new Symbol(value,type));   
		}
		(
		  < COMMA> t=< NDRYSHORE>
		  {
		     
			  id=t.image;
			  value=jin.next();
			  if(isNumeric(value))
			  {
			    type="Number";
			  }
			  else
			  {
			    type="String";
			  }
			  value=value.replace("'","");
			  symbolTable.put(id,new Symbol(value,type));   
		  } 
		)*
		
		|
		
		   < SHKRUAJ>  (   r=expression()  )  
	
			   {
				 System.out.print(r); 
			   }
	
			(
			  < COMMA>  (  r=expression()  ) 
			   {
				     System.out.print(r); 	
			   }
			)*
		
        | 
		< RSHKRUAJ>  (  r=expression()  ) 

		   {
		      System.out.println();
		      
		      System.out.println(r); 	
			  
		   }

				(
				  < COMMA>  ( r=expression()  )
				   {
					    System.out.println(r); 	
				   }
				)*
		
		|
		
		t= < NDRYSHORE> < EQUAL>   ( r=expression() )
		{
		    id=t.image;
			value=""+r;
					
			symbolTable.put(id,new Symbol(value,"Number"));
		}
       
	 
	)*
}






